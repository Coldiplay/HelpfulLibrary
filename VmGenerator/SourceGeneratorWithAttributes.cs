using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace VmGenerator;

/// <summary>
/// A sample source generator that creates a custom report based on class properties. The target class should be annotated with the 'Generators.ReportAttribute' attribute.
/// When using the source code as a baseline, an incremental source generator is preferable because it reduces the performance overhead.
/// </summary>
[Generator]
public class SourceGeneratorWithAttributes : IIncrementalGenerator
{
    private const string NamespaceVms = "GeneratedVm";
    private const string NamespaceDtos = "GeneratedDto";
    private const string NamespaceAttributes = "GeneratedAttributes";

    private const string AttributeNameVm = "CreateVmAttribute";
    private const string AttributeNameDto = "CreateDtoAttribute";

    private const string AttributeVmSourceCode = $@"// <auto-generated/>

namespace {NamespaceAttributes}
{{
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public class {AttributeNameVm} : System.Attribute
    {{
        
    }}
}}";

    private const string AttributeDtoSourceCode = $@"// <auto-generated/>

namespace {NamespaceAttributes}
{{
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public class {AttributeNameDto} : System.Attribute
    {{
        
    }}
}}
";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add the marker attribute to the compilation.
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource(
                $"{AttributeNameVm}.g.cs",
                SourceText.From(AttributeVmSourceCode, Encoding.UTF8));

            ctx.AddSource(
                $"{AttributeNameDto}.g.cs",
                SourceText.From(AttributeVmSourceCode, Encoding.UTF8));
        });

        // Filter classes annotated with the [CreateVm] attribute and [CreateDto] attribute.
        // Only filtered Syntax Nodes can trigger code generation.
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclaration(ctx))
            .Where(t => t.attributeFound)
            .Select((t, _) => t.Item1);

        // Generate the source code.
        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            ((ctx, t) => GenerateCode(ctx, t.Left, t.Right)));
    }

    /// <summary>
    /// Checks whether the Node is annotated with the [CreateVm] attribute and maps syntax context to the specific node type (ClassDeclarationSyntax).
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate</param>
    /// <returns>The specific cast and whether the attribute was found.</returns>
    private static (ClassDeclarationSyntax, bool attributeFound) GetClassDeclaration(
        GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        // Go through all attributes of the class.
        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
        foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                continue; // if we can't get the symbol, ignore it

            string attributeName = attributeSymbol.ContainingType.ToDisplayString();

            // Check the full name of the [CreateVm] attribute.
            if (attributeName == $"{NamespaceAttributes}.{AttributeNameVm}"
                    || attributeName == $"{NamespaceAttributes}.{AttributeNameDto}")
                return (classDeclarationSyntax, true);
        }

        return (classDeclarationSyntax, false);
    }

    // TODO: Реализовать генерацию типов с разными атрибутами

    /// <summary>
    /// Generate code action.
    /// It will be executed on specific nodes (ClassDeclarationSyntax annotated with the [CreateVm] attribute) changed by the user.
    /// </summary>
    /// <param name="context">Source generation context used to add source files.</param>
    /// <param name="compilation">Compilation used to provide access to the Semantic Model.</param>
    /// <param name="classDeclarations">Nodes annotated with the [CreateVm] attribute that trigger the generate action.</param>
    private void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        // Go through all filtered class declarations.
        foreach (var classDeclarationSyntax in classDeclarations)
        {
            // We need to get semantic model of the class to retrieve metadata.
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            // Symbols allow us to get the compile-time information.
            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            // 'Identifier' means the token of the node. Get class name from the syntax node.
            var className = classDeclarationSyntax.Identifier.Text + "Vm";
            var classNameWoVm = classDeclarationSyntax.Identifier.Text;

            var sb = new StringBuilder();
            var props = classSymbol.GetMembers().OfType<IPropertySymbol>().ToList();
            foreach (var prop in props)
            {
                var setMethodNullBool = prop.SetMethod is null;
                var getMethodNullBool = prop.GetMethod is null;
                
                switch (setMethodNullBool)
                {
                    case true when getMethodNullBool:
                        break;
                    case true when !getMethodNullBool:
                        sb.AppendLine($@"
    public {prop.Type} {prop.Name} => Model.{prop.Name};
");
                        break;
                    case false when getMethodNullBool:
                        sb.AppendLine($@"
    public {prop.Type} {prop.Name}
    {{
        set
        {{
            if (value == Model.{prop.Name}) return;
            Model.{prop.Name} = value;
            OnPropertyChanged();
        }}
    }}
");
                        break;
                    case false when !getMethodNullBool:
                        sb.AppendLine($@"
    public {prop.Type} {prop.Name}
    {{
        get => Model.{prop.Name};
        set
        {{
            if (value == Model.{prop.Name}) return;
            Model.{prop.Name} = value;
            OnPropertyChanged();
        }}
    }}
");
                        break;
                }
            }
            
            /*
            // Go through all class members with a particular type (property) to generate method lines.
            var methodBody = classSymbol.GetMembers()
                .OfType<IPropertySymbol>()
                .Select(p =>
                    $@"        yield return $""{p.Name}:{{this.{p.Name}}}"";"); // e.g. yield return $"Id:{this.Id}";
            */

            // Build up the source code
            var code = $@"// <auto-generated/>

using System;
using System.Collections.Generic;
using VmSource.Abstract.Vms;

namespace {namespaceName};

public partial class {className}({classNameWoVm} model) : BaseModelVm<{classNameWoVm}>(model)
{{
{sb.ToString()}
}}
";

            // Add the source code to the compilation.
            context.AddSource($"{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }

    private void GenerateCodeCreateDtoAttribute(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        // Go through all filtered class declarations.
        foreach (var classDeclarationSyntax in classDeclarations)
        {
            // We need to get semantic model of the class to retrieve metadata.
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            // Symbols allow us to get the compile-time information.
            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            // 'Identifier' means the token of the node. Get class name from the syntax node.
            var dtoClassName = classDeclarationSyntax.Identifier.Text + "Dto";
            var originalClassName = classDeclarationSyntax.Identifier.Text;

            var sbPropsDeclarations = new StringBuilder();
            var sbConvertToModel = new StringBuilder();
            var sbConvertToDto = new StringBuilder();


            var props = classSymbol.GetMembers().OfType<IPropertySymbol>().ToList();
            foreach (var prop in props)
            {
                var isBadProp =
                    prop.IsReadOnly ||
                    prop.IsWriteOnly ||
                    prop.SetMethod?.DeclaredAccessibility != Accessibility.Public ||
                    prop.GetMethod?.DeclaredAccessibility != Accessibility.Public;


                if (isBadProp) return;

                sbPropsDeclarations.AppendLine(@$"
    public {prop.Type} {prop.Name} {{ get; set; }}
");

                sbConvertToModel.AppendLine(@$"
                    {prop.Name} = dto.{prop.Name};
");

                sbConvertToDto.AppendLine(@$"
                    {prop.Name} = model.{prop.Name};
");
            }

            // Build up the source code
            var code = $@"// <auto-generated/>

using System;
using System.Collections.Generic;

namespace {namespaceName};

public partial class {dtoClassName}
{{
    public {dtoClassName}() {{ }}

{sbPropsDeclarations}

public static explicit operator {originalClassName}({dtoClassName} dto) =>
            new {originalClassName}()
                {{
{sbConvertToModel}  
                }};

public static explicit operator {dtoClassName}({originalClassName} model) =>
            new {dtoClassName}()
                {{
{sbConvertToDto}  
                }};
}}
";

            // Add the source code to the compilation.
            context.AddSource($"{dtoClassName}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }
}